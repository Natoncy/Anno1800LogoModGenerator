using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Formats.Png;
using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp.Processing;
using System.Diagnostics;
using System.IO.Compression;
using System.Text;


namespace Anno1800LogoModGenerator
{
    internal class Program
    {
        private const int LargeSize = 512;
        private const int SmallSize = 128;

        private static int StartingGuid { get; set; } = StartPersonalModRange; // Starting personal use GUID range https://github.com/anno-mods/GuidRanges

        private const int StartModRange = 1337471142;
        private const int StartPersonalModRange = 2001000000;
        private const int EndPersonalModRange = 2001009999;

        static void Main(string[] args)
        {
            if (args?.Length > 0)
            {
                if (int.TryParse(args[0], out int guid))
                {
                    if (guid < StartModRange)
                    {
                        Console.WriteLine($"ERROR: Starting Guid not in the mod range (>={StartModRange})");
                        OnClose();
                        return;
                    }
                    StartingGuid = guid;
                }
                else
                {
                    Console.WriteLine($"ERROR: Input value not a valid number");
                    OnClose();
                    return;
                }
            }

            var (zipBytes, usedGuids) = CreateModZip();

            File.WriteAllBytes("logo_mod.zip", zipBytes);

            if(usedGuids.Any(x => x >= StartPersonalModRange && x <= EndPersonalModRange))
            {
                Console.WriteLine("WARNING: This mod will use guids in the personal range. Do not publish/upload it, personal use only! It might break this/other mods. More infos at https://github.com/anno-mods/GuidRanges");
            }

            if (usedGuids.Any(x => !(x >= StartPersonalModRange && x <= EndPersonalModRange)))
            {
                Console.WriteLine("WARNING: This mod will use guids in the public range. Make sure you have claimed the guids and have not used them already. It might break this/other mods. Update the modinfo.json before publish. More infos at https://github.com/anno-mods/GuidRanges");
            }

            Console.WriteLine();
            Console.WriteLine($"Mod created successfully using the following guids: {string.Join(", ", usedGuids)}");
            OnClose();
        }

        private static void OnClose()
        {
            Console.WriteLine();
            Console.WriteLine("Press any key to close");
            Console.ReadKey();
        }

        private static (byte[], int[]) CreateModZip()
        {
            var inputFolderPath = Path.Combine(Directory.GetCurrentDirectory(), "input");
            Directory.CreateDirectory(inputFolderPath);

            var logoFiles = Directory.GetFiles(inputFolderPath)
                .Where(x => x.EndsWith(".png"))
                .OrderBy(x => x)
                .Select((x, i) => (x, StartingGuid + i))
                .ToList();


            using var memoryStream = new MemoryStream();

            using (var archive = new ZipArchive(memoryStream, ZipArchiveMode.Create, leaveOpen: true))
            {
                // Add modinfo.json
                var modInfoEntry = archive.CreateEntry("modinfo.json");
                using (var writer = new StreamWriter(modInfoEntry.Open(), Encoding.UTF8))
                {
                    string json = """
                {
                  "Version":"1.0",
                  "ModID":"AutoGenerated_Custom_Logos",
                  "IncompatibleIds":null,
                  "ModDependencies":null,
                  "Category":{
                    "Chinese":null,
                    "English":"Misc",
                    "French":null,
                    "German":null,
                    "Italian":null,
                    "Japanese":null,
                    "Korean":null,
                    "Polish":null,
                    "Russian":null,
                    "Spanish":null,
                    "Taiwanese":null,
                    "Czech":null
                  },
                  "ModName":{
                    "Chinese":null,
                    "English":"Custom Logos",
                    "French":null,
                    "German":null,
                    "Italian":null,
                    "Japanese":null,
                    "Korean":null,
                    "Polish":null,
                    "Russian":null,
                    "Spanish":null,
                    "Taiwanese":null,
                    "Czech":null
                  },
                  "KnownIssues":null,
                  "DLCDependencies":null,
                  "CreatorName":"Anno 1800 Logo Mod Generator",
                  "CreatorContact":null,
                  "Description":{
                    "Chinese":null,
                    "English":"Custom player logos. Mod generated by a tool.",
                    "French":null,
                    "German":null,
                    "Italian":null,
                    "Japanese":null,
                    "Korean":null,
                    "Polish":null,
                    "Russian":null,
                    "Spanish":null,
                    "Taiwanese":null,
                    "Czech":null
                  }
                }
                """;
                    writer.Write(json);
                }

                var assetsText = @$"
<ModOps>
  <ModOp GUID=""92"" Type=""addNextSibling""> 	
  	";
                foreach (var logoFile in logoFiles)
                {
                    var guid = logoFile.Item2;
                    assetsText += @$"
  	<Asset>
	      <Template>PlayerLogo</Template>
	      <Values>
	          <Standard>
	              <GUID>{guid}</GUID>
	              <Name>Logo_{guid}</Name>
	              <IconFilename>data/modgraphics/ui/logos/large/Logo_{guid}.png</IconFilename>
	          </Standard>
	          <PlayerLogo>
	              <DefaultLogo>data/modgraphics/ui/logos/large/Logo_{guid}.png</DefaultLogo>
	              <MiniLogo>data/modgraphics/ui/logos/small/Logo_{guid}.png</MiniLogo>
	          </PlayerLogo>
	          <Locked>
	              <DefaultLockedState>0</DefaultLockedState>
	          </Locked>
	      </Values>
    </Asset>
    ";
                }

                assetsText += @$"
  </ModOp>
  <ModOp Type=""add"" GUID=""500769"" Path=""/Values/CreateGameScene/Logos"">
  	";
                foreach (var logoFile in logoFiles)
                {
                    assetsText += @$"
      <Item>
          <Logo>{logoFile.Item2}</Logo>
      </Item>
          ";
                }
                assetsText += @$"
  </ModOp>
</ModOps>



";

                var entry = archive.CreateEntry("data/config/export/main/asset/assets.xml");
                using (var assetsWriter = new StreamWriter(entry.Open()))
                {
                    assetsWriter.Write(assetsText);
                }

                foreach (var logoFile in logoFiles)
                {
                    var guid = logoFile.Item2;
                    var (data, dataSmall) = GetIconData(logoFile.x);
                    AddImageFile(archive, $"data/modgraphics/ui/logos/large/Logo_{guid}.png", data);
                    AddImageFile(archive, $"data/modgraphics/ui/logos/small/Logo_{guid}.png", dataSmall);
                }
            }

            memoryStream.Position = 0;
            return (memoryStream.ToArray(), logoFiles.Select(x => x.Item2).ToArray());
        }

        private static (byte[] data, byte[] dataSmall) GetIconData(string path)
        {
            using var image = Image.Load<Rgba32>(path);

            image.Mutate(x => x.Resize(LargeSize, LargeSize));

            for (var i = 0; i < image.Width; i++)
            {
                for (var j = 0; j < image.Height; j++)
                {
                    image[i, j] = new Rgba32(byte.MaxValue, byte.MaxValue, byte.MaxValue, image[i, j].A);
                }
            }

            var bytes = image.SaveImageToByteArray();

            image.Mutate(x => x.Resize(SmallSize, SmallSize));

            var bytesSmall = image.SaveImageToByteArray();

            return (bytes, bytesSmall);
        }

        private static void AddImageFile(ZipArchive archive, string path, byte[] imageBytes)
        {
            var entry = archive.CreateEntry(path);
            using (var entryStream = entry.Open())
            {
                entryStream.Write(imageBytes, 0, imageBytes.Length);
            }

            var name = Path.GetFileName(path);
            var tempPathFolder = Path.Combine(Directory.GetCurrentDirectory(), "temp");
            Directory.CreateDirectory(tempPathFolder);

            File.WriteAllBytes($"temp/{name}", imageBytes);
            ExecuteCmd(@$"..\annotex.exe ""{name}"" -l=1", tempPathFolder);

            var ddsBytes = File.ReadAllBytes($"temp/{name.Replace(".png", "_0.dds")}");

            var entryDds = archive.CreateEntry(path.Replace(".png", "_0.dds"));
            using var entryDdsStream = entryDds.Open();
            entryDdsStream.Write(ddsBytes, 0, ddsBytes.Length);
        }


        private static string ExecuteCmd(string command, string? workingDirectory = null)
        {
            // Create a new process to run the command
            ProcessStartInfo processStartInfo = new ProcessStartInfo()
            {
                FileName = "cmd.exe",          // Use cmd.exe to run command-line commands
                Arguments = "/C " + command,   // '/C' tells cmd.exe to execute the command and then terminate
                RedirectStandardOutput = true, // Redirect output to be able to read it
                UseShellExecute = false,      // Must be false to redirect output
                CreateNoWindow = true,        // Do not create a new window for the command
                WorkingDirectory = workingDirectory // Set working directory (optional)
            };

            // Start the process and read the output
            using (Process? process = Process.Start(processStartInfo))
            {
                using (StreamReader? reader = process?.StandardOutput)
                {
                    return reader?.ReadToEnd() ?? "";
                }
            }
        }

    }

    public static class ImageExtensions
    {
        public static byte[] SaveImageToByteArray(this Image<Rgba32> image)
        {
            using (var ms = new MemoryStream())
            {
                image.Save(ms, new PngEncoder()); // You can use any encoder you want
                return ms.ToArray();
            }
        }

    }
}
